"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

class _LanguageHint:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _LanguageHintEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_LanguageHint.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    LANGUAGE_HINT_UNSPECIFIED: _LanguageHint.ValueType  # 0
    LANGUAGE_HINT_LAT: _LanguageHint.ValueType  # 1
    """Latin"""
    LANGUAGE_HINT_GRC: _LanguageHint.ValueType  # 2
    """Greek"""
    LANGUAGE_HINT_SAN: _LanguageHint.ValueType  # 3
    """Sanskrit"""

class LanguageHint(_LanguageHint, metaclass=_LanguageHintEnumTypeWrapper):
    """Language hints mirror the primary schema to avoid cross-spec imports."""

LANGUAGE_HINT_UNSPECIFIED: LanguageHint.ValueType  # 0
LANGUAGE_HINT_LAT: LanguageHint.ValueType  # 1
"""Latin"""
LANGUAGE_HINT_GRC: LanguageHint.ValueType  # 2
"""Greek"""
LANGUAGE_HINT_SAN: LanguageHint.ValueType  # 3
"""Sanskrit"""
Global___LanguageHint: _TypeAlias = LanguageHint  # noqa: Y015

class _ToolStage:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _ToolStageEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_ToolStage.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    TOOL_STAGE_UNSPECIFIED: _ToolStage.ValueType  # 0
    TOOL_STAGE_FETCH: _ToolStage.ValueType  # 1
    """External calls: HTTP/subprocess/db"""
    TOOL_STAGE_EXTRACT: _ToolStage.ValueType  # 2
    """Parse raw response into structured extraction"""
    TOOL_STAGE_DERIVE: _ToolStage.ValueType  # 3
    """Convert extractions to tool-specific facts"""
    TOOL_STAGE_CLAIM: _ToolStage.ValueType  # 4
    """Map derivations into normalized claims"""

class ToolStage(_ToolStage, metaclass=_ToolStageEnumTypeWrapper):
    """Pipeline stage tags to support caching/dispatch."""

TOOL_STAGE_UNSPECIFIED: ToolStage.ValueType  # 0
TOOL_STAGE_FETCH: ToolStage.ValueType  # 1
"""External calls: HTTP/subprocess/db"""
TOOL_STAGE_EXTRACT: ToolStage.ValueType  # 2
"""Parse raw response into structured extraction"""
TOOL_STAGE_DERIVE: ToolStage.ValueType  # 3
"""Convert extractions to tool-specific facts"""
TOOL_STAGE_CLAIM: ToolStage.ValueType  # 4
"""Map derivations into normalized claims"""
Global___ToolStage: _TypeAlias = ToolStage  # noqa: Y015

@_typing.final
class CanonicalCandidate(_message.Message):
    """Structured canonical candidate with encodings and provenance."""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class EncodingsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    LEMMA_FIELD_NUMBER: _builtins.int
    ENCODINGS_FIELD_NUMBER: _builtins.int
    SOURCES_FIELD_NUMBER: _builtins.int
    lemma: _builtins.str
    """Primary lemma (accented if available)"""
    @_builtins.property
    def encodings(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
        """Keyed by encoding: devanagari, iast, slp1, velthuis, hk, accentless, ipa"""

    @_builtins.property
    def sources(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """Tools that proposed this candidate (diogenes, heritage, whitakers, cltk)"""

    def __init__(
        self,
        *,
        lemma: _builtins.str = ...,
        encodings: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        sources: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["encodings", b"encodings", "lemma", b"lemma", "sources", b"sources"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___CanonicalCandidate: _TypeAlias = CanonicalCandidate  # noqa: Y015

@_typing.final
class NormalizedQuery(_message.Message):
    """Normalized representation of a user query prior to planning."""

    DESCRIPTOR: _descriptor.Descriptor

    ORIGINAL_FIELD_NUMBER: _builtins.int
    LANGUAGE_FIELD_NUMBER: _builtins.int
    CANDIDATES_FIELD_NUMBER: _builtins.int
    NORMALIZATIONS_FIELD_NUMBER: _builtins.int
    original: _builtins.str
    """Raw user input"""
    language: Global___LanguageHint.ValueType
    """Language hint supplied or inferred"""
    @_builtins.property
    def candidates(self) -> _containers.RepeatedCompositeFieldContainer[Global___CanonicalCandidate]:
        """Structured canonical candidates"""

    @_builtins.property
    def normalizations(self) -> _containers.RepeatedCompositeFieldContainer[Global___NormalizationStep]:
        """Applied normalization steps"""

    def __init__(
        self,
        *,
        original: _builtins.str = ...,
        language: Global___LanguageHint.ValueType = ...,
        candidates: _abc.Iterable[Global___CanonicalCandidate] | None = ...,
        normalizations: _abc.Iterable[Global___NormalizationStep] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["candidates", b"candidates", "language", b"language", "normalizations", b"normalizations", "original", b"original"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___NormalizedQuery: _TypeAlias = NormalizedQuery  # noqa: Y015

@_typing.final
class NormalizationStep(_message.Message):
    """A single normalization operation applied to the query."""

    DESCRIPTOR: _descriptor.Descriptor

    OPERATION_FIELD_NUMBER: _builtins.int
    INPUT_FIELD_NUMBER: _builtins.int
    OUTPUT_FIELD_NUMBER: _builtins.int
    TOOL_FIELD_NUMBER: _builtins.int
    operation: _builtins.str
    """e.g., "transliterate", "lowercase" """
    input: _builtins.str
    """Pre-operation value"""
    output: _builtins.str
    """Post-operation value"""
    tool: _builtins.str
    """Name of the encoder/normalizer"""
    def __init__(
        self,
        *,
        operation: _builtins.str = ...,
        input: _builtins.str = ...,
        output: _builtins.str = ...,
        tool: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["input", b"input", "operation", b"operation", "output", b"output", "tool", b"tool"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___NormalizationStep: _TypeAlias = NormalizationStep  # noqa: Y015

@_typing.final
class ToolCallSpec(_message.Message):
    """Declarative specification of a tool call."""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ParamsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    TOOL_FIELD_NUMBER: _builtins.int
    CALL_ID_FIELD_NUMBER: _builtins.int
    ENDPOINT_FIELD_NUMBER: _builtins.int
    PARAMS_FIELD_NUMBER: _builtins.int
    EXPECTED_RESPONSE_TYPE_FIELD_NUMBER: _builtins.int
    PRIORITY_FIELD_NUMBER: _builtins.int
    OPTIONAL_FIELD_NUMBER: _builtins.int
    STAGE_FIELD_NUMBER: _builtins.int
    SOURCE_CALL_ID_FIELD_NUMBER: _builtins.int
    tool: _builtins.str
    """Registry key for the tool"""
    call_id: _builtins.str
    """Stable UUID for provenance"""
    endpoint: _builtins.str
    """URL or method identifier"""
    expected_response_type: _builtins.str
    """"xml", "html", "json", "text" """
    priority: _builtins.int
    """Relative ordering hint"""
    optional: _builtins.bool
    """If false, failure aborts the plan"""
    stage: Global___ToolStage.ValueType
    """Pipeline stage (fetch, extract, derive, claim)"""
    source_call_id: _builtins.str
    """For non-fetch nodes: upstream call this consumes"""
    @_builtins.property
    def params(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
        """Tool-specific parameters"""

    def __init__(
        self,
        *,
        tool: _builtins.str = ...,
        call_id: _builtins.str = ...,
        endpoint: _builtins.str = ...,
        params: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        expected_response_type: _builtins.str = ...,
        priority: _builtins.int = ...,
        optional: _builtins.bool = ...,
        stage: Global___ToolStage.ValueType = ...,
        source_call_id: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["call_id", b"call_id", "endpoint", b"endpoint", "expected_response_type", b"expected_response_type", "optional", b"optional", "params", b"params", "priority", b"priority", "source_call_id", b"source_call_id", "stage", b"stage", "tool", b"tool"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolCallSpec: _TypeAlias = ToolCallSpec  # noqa: Y015

@_typing.final
class PlanDependency(_message.Message):
    """Execution ordering dependency between tool calls."""

    DESCRIPTOR: _descriptor.Descriptor

    FROM_CALL_ID_FIELD_NUMBER: _builtins.int
    TO_CALL_ID_FIELD_NUMBER: _builtins.int
    RATIONALE_FIELD_NUMBER: _builtins.int
    from_call_id: _builtins.str
    """Parent call that must complete first"""
    to_call_id: _builtins.str
    """Dependent call that waits"""
    rationale: _builtins.str
    """Optional description of why the dependency exists"""
    def __init__(
        self,
        *,
        from_call_id: _builtins.str = ...,
        to_call_id: _builtins.str = ...,
        rationale: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["from_call_id", b"from_call_id", "rationale", b"rationale", "to_call_id", b"to_call_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PlanDependency: _TypeAlias = PlanDependency  # noqa: Y015

@_typing.final
class ToolPlan(_message.Message):
    """Declarative plan describing which tools to call for a query."""

    DESCRIPTOR: _descriptor.Descriptor

    PLAN_ID_FIELD_NUMBER: _builtins.int
    PLAN_HASH_FIELD_NUMBER: _builtins.int
    QUERY_FIELD_NUMBER: _builtins.int
    TOOL_CALLS_FIELD_NUMBER: _builtins.int
    DEPENDENCIES_FIELD_NUMBER: _builtins.int
    CREATED_AT_UNIX_MS_FIELD_NUMBER: _builtins.int
    plan_id: _builtins.str
    """Stable UUID for the plan"""
    plan_hash: _builtins.str
    """Deterministic hash for caching"""
    created_at_unix_ms: _builtins.int
    """Creation time (unix milliseconds)"""
    @_builtins.property
    def query(self) -> Global___NormalizedQuery:
        """Normalized user query"""

    @_builtins.property
    def tool_calls(self) -> _containers.RepeatedCompositeFieldContainer[Global___ToolCallSpec]:
        """Tool calls to execute"""

    @_builtins.property
    def dependencies(self) -> _containers.RepeatedCompositeFieldContainer[Global___PlanDependency]:
        """Execution dependencies"""

    def __init__(
        self,
        *,
        plan_id: _builtins.str = ...,
        plan_hash: _builtins.str = ...,
        query: Global___NormalizedQuery | None = ...,
        tool_calls: _abc.Iterable[Global___ToolCallSpec] | None = ...,
        dependencies: _abc.Iterable[Global___PlanDependency] | None = ...,
        created_at_unix_ms: _builtins.int = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["query", b"query"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["created_at_unix_ms", b"created_at_unix_ms", "dependencies", b"dependencies", "plan_hash", b"plan_hash", "plan_id", b"plan_id", "query", b"query", "tool_calls", b"tool_calls"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolPlan: _TypeAlias = ToolPlan  # noqa: Y015

@_typing.final
class ExecutedPlan(_message.Message):
    """Result of executing a ToolPlan."""

    DESCRIPTOR: _descriptor.Descriptor

    PLAN_ID_FIELD_NUMBER: _builtins.int
    PLAN_HASH_FIELD_NUMBER: _builtins.int
    RESPONSES_FIELD_NUMBER: _builtins.int
    EXECUTION_TIME_MS_FIELD_NUMBER: _builtins.int
    FROM_CACHE_FIELD_NUMBER: _builtins.int
    plan_id: _builtins.str
    """Plan identifier"""
    plan_hash: _builtins.str
    """Hash used for cache lookups"""
    execution_time_ms: _builtins.int
    """Total execution time"""
    from_cache: _builtins.bool
    """True if resolved from cache"""
    @_builtins.property
    def responses(self) -> _containers.RepeatedCompositeFieldContainer[Global___ToolResponseRef]:
        """References to stored responses"""

    def __init__(
        self,
        *,
        plan_id: _builtins.str = ...,
        plan_hash: _builtins.str = ...,
        responses: _abc.Iterable[Global___ToolResponseRef] | None = ...,
        execution_time_ms: _builtins.int = ...,
        from_cache: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["execution_time_ms", b"execution_time_ms", "from_cache", b"from_cache", "plan_hash", b"plan_hash", "plan_id", b"plan_id", "responses", b"responses"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ExecutedPlan: _TypeAlias = ExecutedPlan  # noqa: Y015

@_typing.final
class ToolResponseRef(_message.Message):
    """Reference to a stored tool response."""

    DESCRIPTOR: _descriptor.Descriptor

    TOOL_FIELD_NUMBER: _builtins.int
    CALL_ID_FIELD_NUMBER: _builtins.int
    RESPONSE_ID_FIELD_NUMBER: _builtins.int
    CACHED_FIELD_NUMBER: _builtins.int
    tool: _builtins.str
    """Tool name"""
    call_id: _builtins.str
    """Call identifier"""
    response_id: _builtins.str
    """Stable response ID"""
    cached: _builtins.bool
    """True if response came from cache"""
    def __init__(
        self,
        *,
        tool: _builtins.str = ...,
        call_id: _builtins.str = ...,
        response_id: _builtins.str = ...,
        cached: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["cached", b"cached", "call_id", b"call_id", "response_id", b"response_id", "tool", b"tool"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolResponseRef: _TypeAlias = ToolResponseRef  # noqa: Y015
