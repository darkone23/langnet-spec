# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: query_spec.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CanonicalCandidate",
    "ExecutedPlan",
    "LanguageHint",
    "NormalizationStep",
    "NormalizedQuery",
    "PlanDependency",
    "ToolCallSpec",
    "ToolPlan",
    "ToolResponseRef",
)

from dataclasses import dataclass

import betterproto2

default_message_pool = betterproto2.MessagePool()

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class LanguageHint(betterproto2.Enum):
    """
    Language hints mirror the primary schema to avoid cross-spec imports.
    """

    UNSPECIFIED = 0

    LAT = 1
    """
    Latin
    """

    GRC = 2
    """
    Greek
    """

    SAN = 3
    """
    Sanskrit
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "LANGUAGE_HINT_UNSPECIFIED",
            1: "LANGUAGE_HINT_LAT",
            2: "LANGUAGE_HINT_GRC",
            3: "LANGUAGE_HINT_SAN",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "LANGUAGE_HINT_UNSPECIFIED": 0,
            "LANGUAGE_HINT_LAT": 1,
            "LANGUAGE_HINT_GRC": 2,
            "LANGUAGE_HINT_SAN": 3,
        }


@dataclass(eq=False, repr=False)
class CanonicalCandidate(betterproto2.Message):
    """
    Structured canonical candidate with encodings and provenance.
    """

    lemma: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Primary lemma (accented if available)
    """

    encodings: "dict[str, str]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(betterproto2.TYPE_STRING, betterproto2.TYPE_STRING),
    )
    """
    Keyed by encoding: devanagari, iast, slp1, velthuis, hk, accentless, ipa
    """

    sources: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)
    """
    Tools that proposed this candidate (diogenes, heritage, whitakers, cltk)
    """


default_message_pool.register_message("query_spec", "CanonicalCandidate", CanonicalCandidate)


@dataclass(eq=False, repr=False)
class ExecutedPlan(betterproto2.Message):
    """
    Result of executing a ToolPlan.
    """

    plan_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Plan identifier
    """

    plan_hash: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Hash used for cache lookups
    """

    responses: "list[ToolResponseRef]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    References to stored responses
    """

    execution_time_ms: "int" = betterproto2.field(4, betterproto2.TYPE_INT64)
    """
    Total execution time
    """

    from_cache: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    True if resolved from cache
    """


default_message_pool.register_message("query_spec", "ExecutedPlan", ExecutedPlan)


@dataclass(eq=False, repr=False)
class NormalizationStep(betterproto2.Message):
    """
    A single normalization operation applied to the query.
    """

    operation: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    e.g., "transliterate", "lowercase"
    """

    input: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Pre-operation value
    """

    output: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Post-operation value
    """

    tool: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    Name of the encoder/normalizer
    """


default_message_pool.register_message("query_spec", "NormalizationStep", NormalizationStep)


@dataclass(eq=False, repr=False)
class NormalizedQuery(betterproto2.Message):
    """
    Normalized representation of a user query prior to planning.
    """

    original: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Raw user input
    """

    language: "LanguageHint" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: LanguageHint(0)
    )
    """
    Language hint supplied or inferred
    """

    candidates: "list[CanonicalCandidate]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Structured canonical candidates
    """

    normalizations: "list[NormalizationStep]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Applied normalization steps
    """


default_message_pool.register_message("query_spec", "NormalizedQuery", NormalizedQuery)


@dataclass(eq=False, repr=False)
class PlanDependency(betterproto2.Message):
    """
    Execution ordering dependency between tool calls.
    """

    from_call_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Parent call that must complete first
    """

    to_call_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Dependent call that waits
    """

    rationale: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Optional description of why the dependency exists
    """


default_message_pool.register_message("query_spec", "PlanDependency", PlanDependency)


@dataclass(eq=False, repr=False)
class ToolCallSpec(betterproto2.Message):
    """
    Declarative specification of a tool call.
    """

    tool: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Registry key for the tool
    """

    call_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Stable UUID for provenance
    """

    endpoint: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    URL or method identifier
    """

    params: "dict[str, str]" = betterproto2.field(
        4,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(betterproto2.TYPE_STRING, betterproto2.TYPE_STRING),
    )
    """
    Tool-specific parameters
    """

    expected_response_type: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    "xml", "html", "json", "text"
    """

    priority: "int" = betterproto2.field(6, betterproto2.TYPE_INT32)
    """
    Relative ordering hint
    """

    optional: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    If false, failure aborts the plan
    """


default_message_pool.register_message("query_spec", "ToolCallSpec", ToolCallSpec)


@dataclass(eq=False, repr=False)
class ToolPlan(betterproto2.Message):
    """
    Declarative plan describing which tools to call for a query.
    """

    plan_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Stable UUID for the plan
    """

    plan_hash: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Deterministic hash for caching
    """

    query: "NormalizedQuery | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Normalized user query
    """

    tool_calls: "list[ToolCallSpec]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Tool calls to execute
    """

    dependencies: "list[PlanDependency]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Execution dependencies
    """

    created_at_unix_ms: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)
    """
    Creation time (unix milliseconds)
    """


default_message_pool.register_message("query_spec", "ToolPlan", ToolPlan)


@dataclass(eq=False, repr=False)
class ToolResponseRef(betterproto2.Message):
    """
    Reference to a stored tool response.
    """

    tool: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Tool name
    """

    call_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Call identifier
    """

    response_id: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Stable response ID
    """

    cached: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    True if response came from cache
    """


default_message_pool.register_message("query_spec", "ToolResponseRef", ToolResponseRef)
